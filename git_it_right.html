	<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Git It Right -- A Succinct Introduction to Git</title>


		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/custom.css">
		<link rel="stylesheet" href="css/theme/solarized.css">
		<link rel="stylesheet" href="lib/css/zenburn.css">
		



	</head>

	<body>

	<!--
		<section>
			<h1>Title</h1>
				<p>

					<small></small>

					<ul>
						<li></li>
						<li></li>
						<li></li>
					</ul>

					<pre>Code</pre>

				</p> 


			<aside class="notes">
			</aside>
		</section>
	-->

		<div class="reveal">

			<div class="slides">

				<section>
					<h1>Git It Right</h1>
					<h3>A Succinct Introduction to Git</h3>
					<p>
					<small><b>Bruno Giacobo Pinto</b></small><br>
					<small>bgpinto@inf.ufpel.edu.br | github.com/giacobo1</small><br>
					<small>Universidade Federal de Pelotas (UFPel)</small><br>
					<small>Laboratory of Ubiquitous and Parallel Systems (LUPS)</small>
					</p>

					<aside class="notes">
							- internet?<br>
							- Expectativas..<br>	
							- Git instalado? <br>
							- Alguém já usou Git antes?<br>
							- interromper a qualquer momento<br>
							- Sabem criar/manipular arquivos/diretórios no Linux?


					</aside>

					<img src="images/sacomplogo.png" height="156" width="940" id="sacomplogo">

				</section>

				<section style="text-align: left;">
					<h3>Agenda</h3>
					<ul>
						<li>Histórico</li>
						<li>Introdução</li>
						<li>Conceitos Fundamentais</li>
						<li>Trabalhando Localmente</li>
						<li>Branches</li>
						<li>Analisando Logs</li>
						<li>Trabalhando Remotamente</li>
						<li>Conflitos</li>
						<li>Workflows</li>
						<li>Submodules</li>
						<li>Referências</li>

						<img src="images/git-ebook.png" id="git-logo1">

					</ul>
				</section>

				<section>
					<h1>Histórico</h1>
				</section>

				<section>
					<h2>Sistemas de controle de Versão (VCS)</h2>
					<p>Um VCS é um sistema para registrar mudanças em arquivos ao longo do tempo de forma que versões especificas possam ser recuperadas, analisadas e alteradas.</p>
				</section>

				<section>
					<h2>VCS Locais</h2>
					<p>No início, utilizava-se mecanismos como cópias de arquivos em diretórios diferentes. Essa abordagem, porém, era ineficiente e suscetível a erros.</p>
				</section>

				<section>
					<h2>Automatizar o Processo</h2>
					<p>
						Havia a necessidade, então, de um sistema que gerenciasse diferentes versões de arquivos.
					</p>
				</section>

				<section>
					<h2>RCS e Patches</h2>
					<p>
						Nesse sentido, RCS VCS foi um dos primeiros a se popularizar. Esse sistema gerava patches (diferenças entre versões de arquivos) e os guardava em um formato especial no disco.
					</p>
				</section>

				<section>
					<h2>Necessidade por Colaboração</h2>
					<p>Devido a complexidade crescente que alguns projetos apresentavam, a demanda por meios de colaborar surgiu e passou a ser incorporado por VCSs.</p>
				</section>

				<section>
					<h2>VCS Centralizados</h2>
					<p>Surgem, então, os primeiros VCS centralizados. Esses sistemas guardam todas as versões de arquivos em um servidor central.</p>
				</section>

				<section>
					<h2>VCS Centralizados</h2>
					<p>Antes do aparecimento do Git, VCS centralizados eram o padrão de fato.</p>
				</section>


				<section>
					<h2>Exemplos de VCS Centralizados</h2>
					
					<ul>
						<li>CVS</li>
						<li>Subversion</li>
						<li>Perforce</li>
					</ul>
				</section>

				<section>
					<h2>Desvantagens dos VCS Centralizados</h2>
					<ul>
						<li>Intolerância a falhas
							<ul>
								<li>Servidor</li>
								<li>Disco Rígido</li>
								<li>Conexão Com a Rede</li>
							</ul>
						</li>						
						<li>Inflexível</li>
						<li>Lento</li>
						<li>Sem Isolamento</li>
					</ul>

				</section>

				<section>
					<h2>VCSs Distribuídos</h2>
					<p>Para contrapor os problemas apresentados por VCSs centralizados, surgem os VCS que operam de forma distribuída.</p>
				</section>

				<section>
					<h2>VCS Distribuídos</h2>
					<p>Nesse tipo de VCS, cada desenvolvedor do projeto possui uma cópia local completa do projeto. Isso não só torna trivial a recuperação de eventuais falhas, como também possibilita diversas estratégias de colaboração (mais em Workflows).</p>
				</section>

				<section>
					<h2>Exemplos de VCSs Distribuídos</h2>
					<ul>
						<li>Git</li>
						<li>Mercurial</li>
						<li>Bazaar</li>
						<li>Darcs</li>
					</ul>
				</section>


				<section>
					<h2>Como Surgiu o Git</h2>
					<p>Até 2002, o desenvolvimento do kernel Linux era administrado por meio de patches arquivados em disco e e-mails. No ano seguinte, a comunidade de desenvolvodores decidiu migrar para um DVCS chamado BitKeeper.</p>
				</section>

				<section>
					<h2>Como Surgiu o Git</h2>
					<p>
						Após desentendimentos entre a comunidade de desenvolvedores do kernel Linux e a BitKeeper em 2005, a comunidade decidiu abandonar o uso desse serviço e implementar seu próprio VCS.
					</p>
				</section>

				<section>
					<h2>Como Surgiu o Git</h2>
					<p>Para acomodar adequadamente projetos de grande escala como o kernel Linux, o novo VCS deveria atender as seguintes exigências:</p>

					<ul>
						<li>Velocidade</li>
						<li>Simplicidade</li>
						<li>Suporte a fluxo não linear de desenvolvimento</li>
						<li>Totalmente Distribuído</li>
						<li>Capaz de lidar com grande volume de dados</li>
					</ul>

					<p>Assim surgia, em 2005, um VCS chamado Git.</p>

				</section>



				<section>
					<h1>Introdução</h1>					
				</section>


				<section>
					<h2>O que é, exatamente, o Git?</h2>
					<p align="justify">
						Git é um VCS distribuído Open-Source, multi-plataforma, leve a altamente eficiente. Normalmente, Git é disponibilizado como ferramenta de linha de comando.
					</p>
				</section>

				<section>
					<h2>Um Pouco Além de um VCS</h2>

					<p>
						Pode-se argumentar que Git oferece um pouco mais que só VCS, pois o sistema permite:
					</p>

					<ul>
						<li>Documentar o andamento do projeto por meio de commits</li>
						<li>Plataforma colaborativa para desenvolvimento</li>
						<li>Suporte a correção de bugs em softwares</li>
						<li>Realizar auditorias em um projeto</li>
					</ul>

				</section>

				<section>
					<h2>"Hubs"</h2>
					<p>
						Devido a popularidade do Git, algumas plataformas de colaboração surgiram e adicionaram um "aspecto" social ao estender as funcionalidades originais dessa ferramenta.
					</p>
				</section>

				<section>
					<h2>Exemplo de "Hubs" Populares</h2>
					
					<img src="images/github_logo.jpg" height="143" width="351" id="github-logo">
					<img src="images/bitbucket_logo.png" height="129" width="389" id="bitbucket-logo">
					<img src="images/gitlab_logo.png" height="177" width="284" id="gitlab-logo">

					<aside class="notes" >
						<p>Lembrar da importancia dos Hubs hoje em dai.</p>
					</aside>

				</section>


				<section>
					<h2>Instalando o Git no Linux</h2>
					<p>Via gerenciador de pacotes no Fedora:<br>
					<pre style="text-align:center;"><code>$ sudo yum install git</code></pre>
					</p>
					<p>Via gerenciador de pacotes em sistemas Debian-like:<br>
					<pre style="text-align:center;"><code>$ sudo apt-get install git</code></pre>
					</p>
					<p>Outros meios de instalações em: <br><a href="http://git-scm.com/download/"></a>http://git-scm.com/download/</p>
				</section>

				<section>
					<h2>Configurações do Git</h2>
					<p>
						Git possui 3 níveis de configurações que são manipulados pela ferramenta <b>config</b> da seguinte forma:						
					</p>

					<p>- Configurações do Git para todos os usuários do sistema<br>
					<pre style="text-align:center;"><code>$ git config --system Atributo "Valor" </code></pre>
					</p>
					<p>- Configurações do Git específicas a um usuário<br>
					<pre style="text-align:center;"><code>$ git config --global Atributo "Valor" </code></pre>
					</p>
					<p>- Configurações do Git específicas ao repositório do projeto<br>
					<pre style="text-align:center;"><code>$ git config --local Atributo "Valor" </code></pre>
					</p>
				</section>


				<section>
					<h2>Configurações do Git</h2>
					<p>
						Adicionando credenciais pela primeira vez:
						<pre style="text-align:center;"><code>$ git config --global user.name "Chuck Norris"</code></pre> 
						<pre style="text-align:center;"><code>$ git config --global user.email cnorris@mercenaries.com </code></pre>
						<pre style="text-align:center;"><code>$ git config --global core.editor "vim" </code></pre>
						<pre style="text-align:center;"><code>$ git config --global core.ui auto</code></pre>
					</p>
					
					<aside class="notes">
						<p>
							Explicar os atributos. I.E: core.editor
						</p>	
					</aside>

				</section>

				<section>
					<h2>Obtendo Ajuda</h2>
					Caso você esqueça algum comando, há diversas formas de obter ajuda.

					<pre style="text-align:center;"><code>$ git help verb</code></pre>
					<pre style="text-align:center;"><code>$ git verb --help</code></pre>
					<pre style="text-align:center;"><code>$ main git-verb</code></pre>

					<aside class="notes">
						<p>
							Explicar sobre tab
						</p>	
					</aside>

				</section>


				<section>
					<h1>Conceitos Fundamentais</h1>
					
				</section>

				<section>
					<h2>O que é um repositório?</h2>
					<p>
						Um repositório é um diretório comum cujos arquivos e subdiretórios são de conhecimento do Git. Dessa forma, tudo que for manipulado nesse diretório está sujeito a versionamento pelo Git.
					</p>					

				</section>	

				<section>
					<h2>O que é um repositório?</h2>
					<p>
						Pode-se dizer que um repositório é a representação do projeto em disco gerenciada pelo Git. Repositórios podem ser locais ou remotos. 
					</p>
				</section>

				<section>
					<h2>A Pasta .git/</h2>
					<p>
						Em cada repositório, o Git cria uma pasta "oculta". Nesse diretório são armazenados a base de dados que contém as versões de arquivos que o Git administra, bem como outros <b>objetos</b> importantes. Todos os repositórios clones são construídos usando essa pasta.
					</p>
				</section>

				<section>
					<h2>Os 3 Estados de um Repositório</h2>

					<img src="images/repo_states.png" height="396" width="686" id="repo-states">


					<aside class="notes">
						<p>
							Chamar atenção para essa parte.
						</p>	
					</aside>
				</section>

				<section>
					<h2>Os 3 Estados de um Repositório</h2>
					<ul>
						<li>Working Directory: É o diretório gerenciado pelo Git. Todos os arquivos dentro desse diretório <b>podem</b> ser registrados na base de dados do Git.</li>
						<li>Staging Area: Também chamado de index. Pode ser visto como o conjunto de mudanças <b>que se quer</b> gravar no repositório.</li>
						<li>Repository: O histórico ou conjunto de versões do projeto</li>
					</ul>
				</section>				



				<section>
					<h2>Snapshots</h2>

					<p>
					Cada variação entre versões é considerada uma imagem parcial ou "snapshot" do estado atual do projeto. Esses snapshots são adicionados à staging area para serem registrados no repositório.
					</p>
				</section>

				<section>
					<h2>Snapshots</h2>
					<p>
						Estes snapshots são gerados usando-se uma soma de verificação (checksum) sobre as diferenças entre versões dos arquivos. O método utilizado para realizar esse checksum é o algoritmo de hash SHA-1 de 40 caracteres.
					</p>
					<p>
						Exemplo de uma hash: 
						<span id="hash1">dcdb1ed165f630d55e73e37423497031d4761876 </span>
					</p>
				</section>

				<section>
					<h2>Snapshots</h2>
					<p>
						Cada hash gerada é <b>única</b>, garantindo a integridade dos arquivos versionados. Ainda, Git <b>armazena apenas snapshots e links</b> para snapshots. Dessa forma, a ferramenta consegue elimina redundâncias de uma forma eficiente. 
					</p>
				</section>

				<section>
					<h2>Commits</h2>
					<p>
						Commits são links (ligações ou ponteiros) para snapshots que recebem anotações e são armazenados no histórico do repositório. Para referir-se a um commits, basta usar o SHA-1 do snapshot que ele aponta.
					</p>

					<aside class="notes">
						Não mencionei git add ainda...
						Da pra argumentar que: assim conclui como e o que o git manipula as coisas.
						Ressaltar que as ferramentas do git são commits e branches						
					</aside>

				</section>


				<section>
					<h1>Trabalhando Localmente</h1>	
					<aside class="notes">
						Lembrar que, no git, quase tudo ocorre localmente. Logo, há um aumento da eficiencia;

					</aside>				
				</section>

				<section>
					<h2>Criando um Repositório Local</h2>

					<p>
						<pre style="text-align:center;"><code>$ git init "repo"</code></pre>
					</p>

					<p>
						O comando acima cria um repositório (.git/) dentro do novo diretório chamado "repo". Usando o mesmo comando, porém sem adicionar o nome, cria um repositório no diretório corrente.
					</p>
				</section>

				<section>
					<h2>Criando um Repositório Remoto</h2>
					<p>
						<pre style="text-align:center;"><code>$ git init --bare "repo"</code></pre>
						A principal diferença para um repositório local é que <b>não há staging area</b> em repositórios remotos. Esse tipo de repositório serve para compartilhamento entre colaboradores.
					</p>
				</section>

				<section>
					<h2>Clonando Repositórios</h2>

					<p>
						Para contribuir com um projeto versionado com o Git e hospedado remotamente, faz-se uma cópia completa (clone) do repositório remoto da seguinte forma:
					</p>

					<p>
						<pre style="text-align:center;"><code>$ git clone "URL" [target] </code></pre>
					</p>

					<p>
						Se target foir especificado, o repositório clonado será criado dentro da pasta com esse nome, caso contrário Git criará um diretório com o mesmo nome do repositório remoto. 
					</p>

				</section>

				<section>
					<h2>Clonando Repositórios</h2>
					<p>
						Git suporta diversos protocolos para transferência de dados. Os mais comuns são:
						<ul>
							<li>HTTPS: https:// ...</li>
							<li>SSH: user@server:caminho/do/repo.git</li>
							<li>Protocolo próprio: git://</li>
						</ul>
					</p>

				</section>

				<section>
					<h2>O Processo de Registro de Arquivos</h2>

					<p>
						Em um repositório, <b>arquivos</b> podem estar em 4 estados (ou status) distintos em relação ao histórico do projeto, são eles:

						<ul>
							<li>Não Registrado</li>
							<li>Não Modificado</li>
							<li>Modificado</li>
							<li>Pronto para Commit (staged)</li>
						</ul>
					</p>

				</section>

				<section>
					<h2>O Processo de Registro de Arquivos</h2>
					<img src="images/file-lifecycle.jpg" height="317" width="500" id="file-lifecycle" >
				</section>

				<section>
					<h2>Alterando o "Status" de um Arquivo</h2>
					<p>
						Registrar um arquivo, portanto, é o processo de alterar o "status" desse arquivo em relação ao repositório.
					</p>
				</section>

				<section>
					<h2>Alterando o "Status" de um Arquivo</h2>
					<p>
						Quando um arquivo é adicionado repositório, seu status é Não Registrado. Para mudar isso, utilizamos o comando:<br>
						<pre style="text-align:center;"><code>$ git add [nome | . ]</code></pre><br>
						Dessa forma, o arquivo passa de <b>Não Registrado</b> para <b>Pronto para Commit</b> e reside na <b>staging area</b>. A partir de agora, o Git tem conhecimento do arquivo e rastreará eventuais mudanças futuras que ocorrerem nesse arquivo.	
					</p>
				</section>
				<section>
					<h2>Alterando o "Status" de um Arquivo</h2>
					<p>
						Arquivos já registrados pelo Git possuem status <b>Não Modificado</b>. Caso alguma alteração sobre esses arquivos seja efetuada, eles passarão para o status <b>Modificado</b>. Para que as modificações sejam efetivamente registradas, faz-se necessário utilizar o comando <i>add</i> novamente, o que leva o arquivo para staging area com o status de <b>Pronto para Commit</b>.
					</p>
				</section>

				<section>
					<h2>Ignorando Arquivos</h2>
					<p>
						Uma vez que um arquivo torna-se conhecido pelo Git, ou seja, entra em status <b>Não Modificado</b>, ele não será esquecido. Em alguns casos, porém, há arquivos desnecessários que não gostaríamos que fizessem parte do repositório.
					</p>
				</section>
					
				<section>
					<h2>Ignorando Arquivos</h2>
					<p>
						Git usa um arquivo chamado <i>.gitignore</i> cujo <b>conteúdo</b> descreve padrões a serem ignorados.
						Exemplo:<br>
						<pre style="text-align:center;"> <code> *.pdf *.[oa] .*~ *.cpp caminho/xuxa.hs # comentario</code></pre>
					</p>

					<p>
						Para que esse arquivo especial tenha efeito, porém, ele deve ser adicionado ao repositório como qualquer outro.
					</p>
				</section>

				<section>
					<h3>Salvando  Arquivos no Histórico do Repositório </h3>
					<p>
						Uma vez que os arquivos tenham sido editados e estão em um versão desejável, ou seja <b> Prontos para Commit </b>, eles podem ser de fato registrados no histórico do repositório.
					</p>
				</section>

				<section>
					<h2>Commitando</h2>
					<p>
						<pre style="text-align:center"><code>$ git commit -m "Mensagem significativa explicando mudanças"</code></pre>
						O comando acima salva <b>todos os arquivos que estão na staging area</b> no histórico do repositório. A opção <i>-m</i> é utilizada caso não haja nenhum editor previamente configurado.
					</p>
				</section>

				<section>
					<h2>Corrigindo um Commit</h2>
					<p>
						Caso algum arquivo seja esquecido durante o processo de commit, é possível reescrever o commit mais recente para corrigir o engano. Para isso, após adicionar os arquivos esquecidos na stating area, usa-se:<br>
						<pre style="text-align:center"><code>$ git commit --amend -m "Esqueceram de mim 313."</code></pre>
					</p>
				</section>

				<section>
					<h2>Avaliando o Estado do Repositório</h2>
					<p>
						É de vital importância saber em qual status os arquivos versionados estão. É exatamente essa a função do seguinte comando:<br>
						<pre style="text-align:center;"><code>$ git status</code></pre>
						Além de informar em que estado os arquivos se encontram no momento, esse comando fornece informações relativas aos branches locais e remotos.
					</p>
				</section>

				<section>
					<h2>Removendo Arquivos</h2>
					<p>
						Em muitas ocasiões, é necessário deletar arquivos. Sendo esse o caso, use:
						<pre style="text-align:center;"><code>$ git rm "nome"</code></pre>
						O Arquivo removido mudará do status <b>Não Modificado</b> para <b>Modificado</b>. Sendo necessário adicionar esses mudanças usando os comandos <i>add</i> e <i>commit</i>. Com essa configuração, o arquivo é apagado do disco.
					</p>
				</section>

				<section>
					
				
					<h2>Removendo Arquivos</h2>

					<p>
						Uma forma não agressiva de fazer com que o git "esqueça" de um arquivo, ou seja deixe de versioná-lo, é usando:<br>
						<pre style="text-align:center;"><code>$ git rm --cached "nome"</code></pre>
						Após executar esse comando, o Git remove o arquivo do <b>histórico</b> e muda o status do arquivo para <b>Modificado</b>. Dessa forma, o arquivo continua no disco, porém não estará mais sob controle de versão após commit.
					</p>
				</section>	

				<section>
					<h2>Renomeando Arquivos</h2>
					<p>
						Para renomear arquivos/diretórios ou movê-los de lugar, usa-se o comando:
						<pre style="text-align:center;"><code>$ git mv "nome-antigo" "nome-novo"</code></pre>
						Caso o diretório seja o mesmo, Git somente renomeará o objeto. As alterações vão para a staging area e necessitaram, dessa forma, serem commitadas.
					</p>

					<aside class="notes">
						Nesse ponto, dá para argumentar que o git parece
						um mini-sistema de arquivos...
					</aside>

				</section>

				<section>
					<h2>Desfazendo Mudanças</h2>
					<p>
						É muito comum que erros sejam cometidos durante o preocesso de versionamento. Devido a flexibilidade do Git, há diversas formas de lidar com mudanças ou edições indesejadas.
					</p>
				</section>

				<section>
					<h2>Revertendo Arquivos Modificados</h2>
					<p>
						Para reverter mudanças em arquivos que ainda não foram movidos para a staging area, ou seja que saíram de <b>Não Modificados</b> para <b>Modificados</b>, pode-se utilizar o comando:<br>
						<pre style="text-align:center;"><code>$ git checkout -- "nome"</code></pre>
						Assim, as mudanças recém feitas serão revertidas e os arquivos retornaram a versão idêntica à presente no working directory.
					</p>


					<aside class="notes">
						Lembrar que o checkout é um curinga perigoso
					</aside>

				</section>

				<section>
					<h2>Resetando a Staging Area</h2>
					<p>
						Caso queiramos desfazer mudanças em arquivos que já estão <b>Prontos para Commit</b>, devemos utilizar o comando:<br>
						<pre style="text-align:center;"><code>$ git reset HEAD [nome | .]</code></pre>

						Da mesma forma que <i>checkout</i>, os arquivos retornam ao status anterior.
					</p>

					<aside class="notes">
						Criar slides sobre: commit --amend e stashing e revert

						Comentar sobre o HEAD em branches

						*** PAREI AQUI ****

					</aside>

				</section>


				<section>
					<h2>Revertendo o Histórico</h2>

					<p>
						Há situações em que medidas drásticas são necessárias para que o repositório seja "estabilizado". Em alguns casos, a reescrita de parte do histórico é uma alternativa.
					</p>

				</section>

				<section>
					<h2>Reescrevendo o Histórico</h2>
					<p>
						Para realizar essa tarefa "agressiva", utiliza-se a versão hard do comando <i>reset</i>, da seguinte forma:<br>
						<pre style="text-align:center;"><code>$ git reset --hard SHA-1</code></pre>

						Onde SHA-1 representa o ponto do histórico (commit) até onde se quer retroceder. Use <i>reset</i> com moderação.
					</p>
				</section>


				<section>
					<h2>Revertendo o Histórico</h2>
					<p>
						Uma forma não distrutíva de reverter o histórico é alcançado usando-se o comando:
						<pre style="text-align:center;"><code>$ git revert SHA-1</code></pre>

						Git revert, como o nome sugere, reverte o commit especificado pelo SHA-1 ao criar um outro commit registrando as mudanças geradas na reversão. É provável que esse comando gere conflitos.
					</p>

					<aside class="notes">
						falar de conflitos (mais adiante)
					</aside>
				</section>



				<section>
					<h1>Branches</h1>
					<img src="images/git_branching_model.png" height="317" width="599" id="git_branching_model">					
				</section>

				<section>
					<h2>O que é um Branch?</h2>
					<p>
						Um branch (ou ramo) pode ser visto como um histórico <b>paralelo</b> e <b>isolado</b>do projeto. Apesar de essa funcionalidade estar presente em muitos VCSs, ela tende a ser ineficiente em muitos casos. 
					</p>
				</section>

				<section>
					<h2>Como Branches Funcionam no Git?</h2>
					<p>
						No Git, um branch é, basicamente, uma <b>referência (ou ponteiro) nomeada</b> para um <b>conjunto</b> de um ou mais commits. Logo, em Git, deve sempre haver pelo menos 1 branch e ao menos um commit. Como commits denotam pontos no histórico do projeto, o seu conjunto pode ser entendido como o histórico em si.
					</p>
				</section>


				<section>
					<h2>Como Branches Funcionam no Git?</h2>
					<img src="images/git_branch.png" height="370" width="572" id="git_branch" >
				</section>

				<section>
					<h2>Criando Branches no Git</h2>
					<p>
						Para criar um branch no Git, basta usar o comando:<br>
						<pre style="text-align:center;"><code>$ git branch "branch_name"</code></pre>

						Por padrão, o Git cria um branch chamado <i>master</i>. Esse branch, porém, é um branch comum.
					</p>
					<!--
						Falar sobre possibilidade de criar um branch a partir de um commit e o uso do checkout

						tem o --list e tb o filtro de commits;
					-->
				</section>

				
				<section>
				<h2>Listando Branches Criados</h2>
				<p>
					Para listar todos os branches, tanto locais, quanto remotos, use:<br>
					<pre style="text-align:center;"><code>$ git branch -a</code></pre>
					Caso deseje listar somente branches locais, omita a opção <i>-a</i> ou use <i>--list</i>. Para visualizar rapidamente os últimos commits em cada branch, adicione a opção <i>-v</i>.
				</p>	
				</section>

				<section>
				<h2>Deletando Branches</h2>
				<p>
					Para deletar um branch local, use:<br>
					<pre style="text-align:center;"><code>$ git branch -d "branch_name"</code></pre>

					Use a opção <i>-D</i> para forçar a remoção do branch, caso necessário.
				</p>	
				</section>


				<section>
				<h2>Navegando Entre Commits</h2>
				<p>
					Para navegar entre branches e alternar entre históricos, use o comando:<br>
					<pre style="text-align:center;"><code>$ git checkout "branch_name"</code></pre>
					Note, pórém, que a stagint area deve estar vazia para que a navegação ocorra, do contrário, Git pede que ações sejam tomadas a esse respeito.
				</p>	
				</section>

				<section>
				<h2>Combinando Branches</h2>
				<p>
					Em algum ponto do projeto, branches podem ser combinados. Assim, o progresso alcançado e versionado em um branch pode ser "conhecido" e <b>incorporado</b> por outro branch. A habilidade de combinar branches é extremamente importante em diversas ocasiões.
				</p>	
				</section>

				<section>
				<h2>Combinando Branches no Git</h2>
				<p>
					Combinar branches no Git ocorre por meio do comando:<br>
					<pre style="text-align:center;"><code>$ git merge "branch_name"</code></pre>
					É importante ressaltar que, para combinar branches, deve-se estar no branch ao qual se quer incorparar as mudanças presentes no branch denotado por "branch_name".
				</p>	
				</section>

				<section>
				<h2>Combinando Branches no Git</h2>
					<img src="images/git_merge.png" height="256" width="512" id="git_merge">

				</section>

				<section>
				<h2>Combinando Branches no Git</h2>
				<p>
					Quando um <i>merge</i> ocorre, Git simplismente redireciona as referencias (ponteiros) para que os commits possam apontar seus novos sucessores. Note que nenhum branch foi deletado e nenhum commit perdido. Nesse processo, salvo a adição de commits no branch alvo, nada é sobrescrito ou deletado.
 				</p>	
				</section>

				<section>
				<h2>Mudando a "Base" de um Branch</h2>
				<p>
					Há casos em que é necessário sobrescrever totalmente a referência para o qual um branch aponta. Isso é alcançado utilizando-se o comando:<br>
					<pre style="text-align:center;"><code>$ git rebase "branch_name"</code></pre>
					De forma análoga a <i>merge</i>, o comando <i>rebase</i> requer que o branch escolhido para ser a nova base do branch "branch_name" a ser integrado seja o branch corrente. Ao contrário do <i>merge</i>, <i>rebase</i> <b>não</b> pode ser desfeito.

				</p>	
				</section>

				<section>
				<h2>Mudando a "Base" de um Branch</h2>
				<img src="images/git_rebase.png" height="305" width="456" id="git_rebase">	
				</section>

				<section>
					<h2> Branches <3 </h2>
					<img src="images/git_meme.png" height="394" width="736" id="git_meme">
				</section>


				<section>
					<h1>Trabalhando Remotamente</h1>
					
				</section>


				<section>
					<h1>Conflitos</h1>
					
				</section>

				<section>
				<h2>O que são Conflitos?</h2>
				<p>
					Conflitos são divergências no histórico que o Git não consegue resolver sozinho. Normalmente, elas ocorrem em decorrência de um merge ou da manipulação de um mesmo arquivo por colaboradores ou branches diferentes, impedindo que o Git tome alguma decisão à respeito.
				</p>	
				</section>


				<section>
					<h1>Workflows</h1>
					
				</section>


				<section>
					<h1>Analisando Logs</h1>
					
				</section>


				<section>
					<h1>Referências</h1>
					
				</section>



			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			Reveal.initialize({
								controls:false,
							   	history:true,
							   	slideNumber:true,
							   	dependencies: [
							   		{ src: 'plugin/notes/notes.js', async: true },
							   		{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
							   	]							   	

							   });

		</script>

	</body>
</html>
